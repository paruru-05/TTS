<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voice Impact - Direct Sync</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Serif+JP:wght@900&display=swap');
        body { background-color: #000; font-family: 'Noto Serif JP', serif; }
        .scrollbar-hide::-webkit-scrollbar { display: none; }
        .glass { background: rgba(10, 10, 10, 0.85); backdrop-filter: blur(12px); }
    </style>
</head>
<body class="min-h-screen flex items-center justify-center p-4">

    <div class="max-w-md w-full space-y-4">
        <div class="glass rounded-[3rem] border border-red-950/40 p-8 shadow-[0_0_120px_rgba(220,38,38,0.2)] relative">
            
            <header class="text-center mb-6">
                <i data-lucide="mic-2" class="mx-auto text-red-600 mb-2 animate-pulse"></i>
                <h1 class="text-3xl font-black italic tracking-tighter text-red-800 uppercase">Direct Sync</h1>
                <p class="text-[9px] text-zinc-600 tracking-[0.4em] uppercase font-sans">Gemini 2.5 TTS Engine</p>
            </header>

            <!-- テキスト入力エリア -->
            <div class="relative mb-6 group">
                <textarea id="custom-text" class="w-full bg-neutral-900/40 rounded-[2rem] p-6 h-72 text-xs leading-relaxed border border-red-900/20 focus:border-red-600/40 outline-none transition-all resize-none scrollbar-hide text-zinc-300" placeholder="p.txtを読み込むか、直接入力してください..."></textarea>
                <div class="absolute top-4 right-6 flex gap-2 opacity-30">
                    <button onclick="fetchExternalText()" class="hover:text-red-500 transition-colors" title="p.txtを再読み込み">
                        <i data-lucide="refresh-cw" size="14"></i>
                    </button>
                </div>
            </div>

            <div class="space-y-3">
                <button id="btn-generate" onclick="generateAudio()" class="w-full py-4 rounded-2xl flex items-center justify-center gap-2 font-bold transition-all bg-zinc-800 text-red-50 hover:bg-zinc-700 active:scale-95 border border-red-900/30 shadow-xl">
                    <i data-lucide="radio" id="gen-icon" size="18"></i>
                    <span id="gen-text">音声を生成</span>
                </button>

                <div class="grid grid-cols-2 gap-3">
                    <button id="btn-play" onclick="togglePlay()" disabled class="py-5 rounded-2xl flex items-center justify-center gap-2 font-black transition-all bg-zinc-900 text-zinc-800 disabled:cursor-not-allowed">
                        <i data-lucide="play" id="play-icon" size="20"></i>
                        <span>PLAY</span>
                    </button>
                    <a id="btn-download" href="#" download="output_voice.wav" class="py-5 rounded-2xl flex items-center justify-center gap-2 font-black transition-all bg-zinc-900 text-zinc-800 pointer-events-none">
                        <i data-lucide="download" size="20"></i>
                        <span>SAVE</span>
                    </a>
                </div>
            </div>
            
            <div class="mt-5 text-center">
                <span id="status-text" class="text-[9px] text-zinc-700 font-bold uppercase tracking-[0.3em]">Status: Standby</span>
            </div>
        </div>

        <!-- ログ -->
        <div class="px-5 py-3 bg-black/60 border border-white/5 rounded-2xl flex items-center gap-4 overflow-hidden">
            <i data-lucide="activity" class="text-red-900 flex-shrink-0" size="12"></i>
            <div id="debug-log" class="text-[10px] text-zinc-600 font-mono italic whitespace-nowrap overflow-hidden text-ellipsis">Waiting for input...</div>
        </div>
    </div>

    <audio id="main-audio" class="hidden"></audio>

    <script>
        const apiKey = ""; 
        const audioEl = document.getElementById('main-audio');
        let currentAudioUrl = null;

        function log(msg) { document.getElementById('debug-log').innerText = msg; }
        function updateStatus(msg) { document.getElementById('status-text').innerText = `Status: ${msg}`; }

        // p.txt を読み込む
        async function fetchExternalText() {
            log('Fetching p.txt...');
            try {
                const res = await fetch('./p.txt', { cache: 'no-store' });
                if (!res.ok) throw new Error('File not found');
                const text = await res.text();
                document.getElementById('custom-text').value = text.trim();
                log('p.txt loaded.');
            } catch (e) {
                log('External p.txt not found. Ready for manual input.');
            }
            lucide.createIcons();
        }

        // 音声生成 (ダイレクト)
        async function generateAudio() {
            const userText = document.getElementById('custom-text').value;
            if (!userText) {
                log('Error: No text input.');
                return;
            }

            const btn = document.getElementById('btn-generate');
            const icon = document.getElementById('gen-icon');
            btn.disabled = true;
            icon.classList.add('animate-spin');
            updateStatus('Generating...');
            log('Sending text directly to TTS engine...');

            try {
                // 指示を含めず、入力されたテキストをそのままTTSに渡す
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${apiKey}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: userText }] }],
                        generationConfig: {
                            responseModalities: ["AUDIO"],
                            speechConfig: {
                                voiceConfig: {
                                    prebuiltVoiceConfig: { voiceName: "Kore" }
                                }
                            }
                        },
                        model: "gemini-2.5-flash-preview-tts"
                    })
                });

                if (!response.ok) {
                    const errorJson = await response.json();
                    throw new Error(errorJson.error?.message || 'TTS Failed');
                }

                const data = await response.json();
                const base64Data = data.candidates?.[0]?.content?.parts?.[0]?.inlineData?.data;
                
                if (!base64Data) throw new Error('Safety filter blocked the content.');

                const mimeType = data.candidates[0].content.parts[0].inlineData.mimeType;
                const sampleRate = parseInt(mimeType.match(/rate=(\d+)/)?.[1] || "24000");

                const blob = pcmToWav(base64Data, sampleRate);
                if (currentAudioUrl) URL.revokeObjectURL(currentAudioUrl);
                currentAudioUrl = URL.createObjectURL(blob);
                audioEl.src = currentAudioUrl;

                // UIの有効化
                document.getElementById('btn-play').disabled = false;
                document.getElementById('btn-play').className = 'py-5 rounded-2xl flex items-center justify-center gap-2 font-black bg-red-700 text-white shadow-lg active:scale-95 transition-all';
                document.getElementById('btn-download').href = currentAudioUrl;
                document.getElementById('btn-download').className = 'py-5 rounded-2xl flex items-center justify-center gap-2 font-black bg-zinc-100 text-black pointer-events-auto active:scale-95 transition-all';

                updateStatus('Complete');
                log('Audio generated successfully.');

            } catch (e) {
                log(`Error: ${e.message}`);
                updateStatus('Error');
            } finally {
                btn.disabled = false;
                icon.classList.remove('animate-spin');
            }
        }

        function togglePlay() {
            const icon = document.getElementById('play-icon');
            if (audioEl.paused) {
                audioEl.play();
                icon.setAttribute('data-lucide', 'pause');
            } else {
                audioEl.pause();
                icon.setAttribute('data-lucide', 'play');
            }
            lucide.createIcons();
        }

        audioEl.onended = () => {
            document.getElementById('play-icon').setAttribute('data-lucide', 'play');
            lucide.createIcons();
        };

        // PCM16 to WAV conversion
        function pcmToWav(base64, sampleRate) {
            const binary = atob(base64.replace(/\s/g, ''));
            const buffer = new ArrayBuffer(binary.length);
            const view = new Uint8Array(buffer);
            for (let i = 0; i < binary.length; i++) view[i] = binary.charCodeAt(i);
            const wav = new ArrayBuffer(44 + buffer.byteLength);
            const dv = new DataView(wav);
            const s = (o, str) => { for (let i = 0; i < str.length; i++) dv.setUint8(o + i, str.charCodeAt(i)); };
            s(0, 'RIFF'); dv.setUint32(4, 36 + buffer.byteLength, true); s(8, 'WAVE'); s(12, 'fmt ');
            dv.setUint32(16, 16, true); dv.setUint16(20, 1, true); dv.setUint16(22, 1, true);
            dv.setUint32(24, sampleRate, true); dv.setUint32(28, sampleRate * 2, true);
            dv.setUint16(32, 2, true); dv.setUint16(34, 16, true); s(36, 'data');
            dv.setUint32(40, buffer.byteLength, true);
            new Uint8Array(wav).set(view, 44);
            return new Blob([wav], { type: 'audio/wav' });
        }

        window.onload = () => {
            lucide.createIcons();
            fetchExternalText();
        };
    </script>
</body>
</html>
